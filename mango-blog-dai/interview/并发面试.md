# 并发

## 1. Java线程的几种状态

* JDK从1.5开始在Thread类中增添了State枚举 **NEW(新建)**、**RUNNABLE(当线程正在运行或者已经就绪正等待CPU时间片)**、**BLOCKED(阻塞)**、**WAITING(无期限等待)**、**TIMED_WAITING(限期等待)**、**TERMINATED(死亡)**六种.

* **阻塞：**线程在等待获取对象同步锁时

* **Waiting**：调用不带超时的wait()或者不带超时的join()

* **TIMED_WAITING**：调用sleep(xx)、或者带超时的wait、join

  ![](../../img/dai/线程5种状态.png)



## 2. 线程安全

* **线程安全：**当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或在调用方法时进行任何其他协调，调用对象都能得到正确结果，那么就成这个对象是线程安全的。（这属于绝对线程安全）
* 线程安全可以分为5类：**不可变、绝对线程安全、相对线程安全、线程兼容和线程对立**
* **不可变：**永远也不会改变，根本不存在线程安全问题。
  * Jdk种不可变得对象有：String、Long/Double等包装类、BigInteger、BigDecimal等大数据类型。AtomicInteger和AtomicLong不是不可变对象
* **绝对线程安全：**
* **相对线程安全：**Vector、HashTable、Collections.synchronizedCollection()
* **线程兼容：**对象本身并非线程安全，但是可以通过外部调用的同步保证线程安全：ArrayList、HashMap等大部分类
* **线程对立：**调用端无论是否采取同步措施都不是线程安全的System.setIn和System.setOut。
* 五个特性：**共享性、互斥性、原子性、可见性、有序性**
* **线程安全的实现方法：**
  * **互斥/阻塞同步：（悲观锁）**
    * **synchronized**：编译后在同步代码段的前后加上monitorenter、monitorexit两个指令；对同一线程来说是可重入的。因为java线程是映射到操作系统的原生线程之上的，阻塞或唤醒一个线程都需要从用户态切换到核心态，状态转换的时间可能比执行同步代码的时间还要长，所以synchronized是一个重量级的操作。
    * ReentrantLock(**重入锁**)**：**也是一个重量级的操作，在语义上与synchronized相同，但是可以进行更精细的控制：等待可中断（可以尝试获取锁）、公平锁（当多个线程都等待同一个锁时必须按照时间顺序获得锁）、锁绑定多个条件（可以同时绑定多个Condition对象）
  * 非阻塞同步：（乐观锁）
    * 先进性操作，如果没有其他线程争用共享数据就操作成功了，如果有就尝产生了冲突，然后在采取其他措施补偿（最常见的就是不断尝试，直到成功）**CAS指令** **例如**:AtomicInteger.incrementAndGet()方法的原子性
  * 无同步方案
    * **可重入代码**：不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入、不调用非可重入的方法 

## 3.  **ThreadLocal的设计理念与作用**

* 线程局部变量，是一种维护线程限制的方法。通常定义为private static类型。它提供了get与set访问器，为每个使用该变量的线程维护一份单独的拷贝，get总是返回当前线程通过set设置的最新的值。
* 当我们在一个类的多个方法中想使用某个变量，但这个变量仅反映当前线程的状态时可以通过方法传参的形式，但是ThreadLocal更优雅。比如DAO的单例实现，它的属性Connection就不是线程安全的，这种情况就可以会用ThreadLocal，这样每次返回的都是同一个连接的副本。

```java
public void set(T value) {
   Thread t = Thread.currentThread();
   ThreadLocalMap map = getMap(t);
   if (map != null)
       map.set(this, value);
   else
      createMap(t, value);
}
```

* **实现机制：**
* 每个Thread对象内部都有一个ThreadLocalMap,可以存放若干个以ThreadLocal为key的Entry对象;ThreadLocal对象就是当前线程ThreadLocalMap的访问入口
* 当我们调用get方法时，现获取当前线程，然后获取当前线程的ThreadLocalMap, **ThreadLocalMap** **是使用** **ThreadLocal** **的弱引用作为** **Key** **的**，如果不为空就以当前ThreadLocal对象为key获取对应的value，如果为空就调用setInitialValue()方法（内部调用了initialValue方法产生value）
* **ThreadLocal可能产生内存泄漏吗？**
* ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收。这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value永远无法回收，造成内存泄漏。Jdk已经考虑到这点，它在每次get和set的时候都会清除Map中key为null的entry。但是当我们结合线程池使用的时候就不能避免了。因为线程在结束之后不会被GC回收而是放回池内待重用。

## 4. 共享对象

* **指令重排**：CPU可能会对输入的代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组以确保其与顺序执行的结果是一致的。JVM的即时编译期中也有类似的指令重排优化。使用**volatile**可以禁止指令重排。
* **使用同步**可以保证原子性和可见性
* **volatile****语义：仅**保证了可见性不能保证原子性、禁止指令重排（通过添加内存屏障）
* 线程封闭技术（不共享变量）也可以保证线程安全，可以通过栈限制或[ThreadLocal]()两种方式实现。
* 创建后状态就不能变的对象是不可变对象，不可变对象天生线程安全。

## 5. 可见性是什么？实现方式？

* **可见性**：一个线程修改了对象的状态后，其它线程能够真正看到改变。**Synchronized**和volatile和final可以实现内存可见性
* **synchronized**：是通过“在unlock之前必须把变量值同步会主内存”这条规则实现
* **final**是指被final修饰的字段在构造器中一旦初始化完成，并且构造器中没有this引用逃逸，那么在其他线程中就能看见final字段的值。
* **volatile**的特殊规则：新值立即同步到主内存中，每次使用前都从主内存中刷新。
* 一个类只有get/set方法都设为synchronized才能保证这个类是线程安全的，只将set方法设为synchronized并不能保证可见性，因为在调用非synchronized的get方法时并不能保证工作内存从主内存刷新数据，所以可能读到脏数据。

## 6. **Volatile的作用以及实现方式**

* **作用：**内存可见性、禁止指令重排
* **实现：**内存可见性是通过新值立即同步到主内存，以及每次使用前立即从主内存刷新；禁止指令重排是通过添加内存屏障的方式，即重排序时不能把后面的指令放到内存屏障之前。

## 7. this引用逃逸

* 是指在构造函数返回之前其他线程就持有该对象的引用。通常发生在以内部类的形式在构造函数中启动一个线程或者注册监听器。
* **改进：**我们可以在构造方法中创建一个线程但是不要启动它。所以我们可以创建一个private的构造方法，然后创建一个工厂方法。

## 8.同步容器

* HashMap、HashSet、ArrayList都不是线程安全的，Vector、HashTable是线程安全的。通过Collections.synchronizedList/Set/Map/SortedSet/SortedMap可以返回一个同步的对应集合

* 使用Vector或者同步的List，返回的Iterator迭代器都是fail-fast的，这意味着如果在迭代过程中，任何其他线程修改List，都会失败，抛出上异常，若想避免该异常则必须在迭代期间对容器加锁。

* **以下类在迭代期间都无需对容器加锁**

  CopyOnWriteArrayList、CopyOnWriteArraySet、[ConcurrentHashMap]()、ConcurrentLinkedQueue、ConcurrentSkipListMap(替代SortedMap)、ConcurrentSkipListSet(替代SortedSet)

* **CopyOnWriteArrayList**：底层维护一个volatile的基础数组，某线程在对容器修改的时候先显示获取锁（只能有一个线程修改），然后复制基础数组（保证了其他读线程不会出错），最后更新原数组（因为是volatile的，所以对其他读线程立即可见）。因为复制数组开销较大，所以适合元素少，修改操作少的情况。

## 9. **HashTable、HashMap、ConcurrentHashMap的区别**

* 主要区别
  * **直观使用上：**HashTable不接受key为null, HashMap接受key为null
  * **哈希冲突的概率不同**：根据Hash值计算数组下标的算法不同，HashTable直接使用对象的hashCode，hashMap做了重新计算，HashTable的冲突几率比HashMap高
  * hashTable默认的数组大小为11，hashMap默认数组大小为16，他们的默认负载因子都是0.75，HashTable扩展为2*size+1, HashMap扩展为2*size
  * **线程安全：**HashTable是线程安全的，HashMap则不是线程安全的, 但是仅仅是Hashtable仅仅是对每个方法进行了synchronized同步，首先这样的**效率**会比较低；其次它**本身的同步**并不能保证程序在并发操作下的正确性（虽然每个方法都是同步的，但客户端调用可能在一个操作中调用多个方法，就不能保证操作原子性了），需要高层次的并发保护。
* ConcurrentHashMap改进：
  * 并发效率问题：Hashtable和Collections.synchronizedMap通过同步每个方法获得线程安全。即当一个线程执行一个Map方法时，无论其他线程要对Map进行什么样操作，都不能执行，直到第一个线程结束才可以。对比来说，**ConcurrentHashMap**所使用的**锁分段技术**，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。从而可以有效提高并发效率。
  * 迭代问题：ConcurrentHashMap返回的iterator是弱一致性的，并不会抛出ConcurrentModifiedException。弱一致性的迭代器可以容许并发修改，迭代器可以感应到迭代器在被创建后，对容器的修改。
  * 增加了常见的原子操作API：它的API中包含一些原子形式的“putIfAbsent()、相等便移除、相等便替换”这些在HashTable中非原子操作

##  10 生产者消费者与阻塞队列

* 常用阻塞队列的实现：
  * FIFO队列：LinkedBlockingQueue、ArrayListBlockingQueue
  * 优先级队列：PriorityBlockingQueue
  * 其中提供了阻塞的take()和put()方法：如果队列是空的，take()将一直阻塞到队列中有内容，如果队列满了put()将阻塞到队列有空闲位置。他们响应中断，当收到中断请求的时候会抛出InterruptedException，提前结束阻塞状态。
  * **SynchronousQueue**：并不是一个真正的队列，直接将任务移交给工作者线程。

## 11 Executor框架、线程池

* 为什么要使用线程池？

  * **资源方面（内存、CPU）**：创建新的线程需要消耗相当一部分内存，增大垃圾回收的压力；
  * **时间方面**：创建线程需要消耗一定时间，带来请求处理的延迟并且需要在JVM与操作系统之间切换进行相应处理。
  * 通过调整线程池中的线程数，可以强制超出限制的线程等待，直到有线程可以处理它，他们等待时所消耗的资源要比额外线程所消耗的资源少，可以防止资源崩溃。

* ThreadPool类别

  * Executor：执行任务的对象，提供一种将任务提交与任务运行分离开的方法--execute()方法。

  * **ExecutorService**：extends Executor,对Executor的扩展，管理生命周期

  * **Executors:**是Executor、Callable的工厂

    ```java
    ExecutorService exec = Executors.newCachedThreadPool();//创建一个可根据需要创建新线程的线程池（最大为Integer.MAXVALUE）闲置 60 秒的线程将终止并从缓存中删除。【等待队列】，因为池是无限的，所以使用了SynchronousQueue，任务直接提交给工作线程提高了效率。
    exec = Executors.newFixedThreadPool(5); //创一个可重用固定大小线程集合的线程池，每当提交一个任务就创建一个线程，直到最大长度。如果某线程因非预期的异常结束线程池将补充一个。【等待队列】默认使用一个无限的LinkedBlockingQueue，队列可能无限增加。
    exec = Executors.newSingleThreadPool(); //创建Executor，使其运行单一线程【等待队列】默认使用一个无限的LinkedBlockingQueue，队列可能无限增加。
    exec.execute(new LiftOff());        //LitOff十一个Runnable类
    ```

  * **【使用场景】：**只有当任务彼此独立的时候才能使用有限池，否则可能引发饥饿死锁。

  * **创建周期任务**

    ```java
    ScheduledExecutorService service = Executors.newScheduledThreadPool(10);
    service.scheduleAtFixedRate(new ScheduledExecutorTest("job1"), initialDelay1,period1, TimeUnit.SECONDS); //也就是第一个线程将在initialDelay1后开始执行，然后第二个在initialDelay1+period1后执行，接着第三个在initialDelay + 2 * period 后执行，依此类推。（是不管上一个线程有没有执行完的）
    service.scheduleWithFixedDelay(new ScheduledExecutorTest("job2"), initialDelay2,delay2, TimeUnit.SECONDS); // 从现在开始initialDelay2秒钟之后第一个线程开始，每个线程结束之后间隔delay2秒钟执行一次job2，每次执行时间为上一次任务结束后向后推一个时间间隔
    ```

* **关闭Executor**

  * **ExecutorService**生命周期有3种状态：运行、关闭、终止
  * shutdown():停止接受新的任务，等待已提交任务的完成
  * shutdownNow():首先尝试关闭正在执行的任务，暂停处理正在等待的任务，返回等待执行的任务列表
  * isShutdown():判断此执行程序是否已经关闭
  * isTerminated():如果shutdown/shutdownNow之后所有任务都已经关闭返回true
  * awaitTermination():等待executorService到达terminated状态

* **Callable、Future、FutureTask**

  * Runnable中的run()方法没有返回值并且不能抛出CheckedException
  * **Callable**是可以返回结果并且可以抛出异常的任务。
  * **Executor**执行**任务的生命周期**有4个阶段：创建、提交、开始和完成。**Future**描述了任务的生命周期
  * **a.**ExectorService.submit(Callable/Runnable)方法会返回一个Future对象
    * **Future对象API:**
    * cancel(boolean mayInterruptIfRunning)：试图取消对此任务的执行，如果任务已经启动，则根据参数判断是否可以中断任务。此方法返回后，对 isDone() 的后续调用将始终返回 true。如果此方法返回 true，则对 isCancelled() 的后续调用将始终返回 true。
    * get()：如果任务已完成则立即返回或抛出异常，如果任务没有完成，会一直阻塞到任务完成。
    * get(long timeout,TimeUnit unit)可以通过不断调用timeout为0个get来判断任务是否已经执行完毕。
  * 显示地为某个任务指定的Runnable或Callable 实例化一个FutureTask。
    * executorService.newTaskFor(Callable<T> task)可以返回一个FutureTask对象，可以把它交给executorService执行

* **ThreadPollExecutor、饱和策略**

  * 当Executors提供的几种线程池不能满足我们的需求时，可以通过ThreadPollExecutor的构造方法来定制线程池。

    ```java
    public ThreadPoolExecutor(int corePoolSize, //核心池大小
         int maximumPoolSize, //最大池大小
         long keepAliveTime, //存活时间
         TimeUnit unit,
         BlockingQueue<Runnable> workQueue, //任务队列
         ThreadFactory threadFactory, //线程工厂
         RejectedExecutionHandler handler) //饱和策略
    ```

  * **饱和策略**：当一个队列充满后或者任务提交到了一个已经被关闭的Executor时，将会用到饱和策略。可以通过`RejectedExecutionHandler`或者调用`setRejectedExecutionHandler()`方法来修改

* **ThreadFactory**

  * ThreadFactory是一个工厂接口，只有一个方法newThread(Runnable r), 通过编写定制的ThreadFactory可以定制由Executor创建的线程的属性（后台、优先级、名称）.

    ```java
    public class DaemonThreadFactory implements ThreadFactory{
          @Override
          public Thread newThread(Runnable r) {
                 Thread t = new Thread(r);
                 t.setDaemon(true);
                 return t;
          }
    }
    exec = Executors.newCachedThreadPool(new DaemonThreadFactory());
    ```

    ​

##  12  **java.util.concurrent.Lock**

* 调节共享对象访问的机制：synchronized、volatile、ReentrantLock

* **synchronized与ReentrantLock的异同：**

  * 它们有相同的**互斥**和**内存可见性**保证。他们同样都具有**可重入性**。
  * 当一线程因为等待获取内部锁而阻塞的时候将一直等待下去并且不能被中断。而ReentrantLock提供了相应的轮询与中断的方法。但是我们在使用显示锁的时候必须记得要在finally语句中释放。使用显式锁的的tryLock可以尝试同时获取多个锁，这样可以避免死锁。显示锁在线程数较多的情况下，性能稍好，但是未来性能的改进更倾向于synchronized，因为它是内置于JVM的。

* **ReentrantLock  API**

  * **tryLock()**：如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；这个方法可以避免死锁：只有当对象要求的锁都能够获取的时候才执行操作，如果有一个不能获取就可以等待一段时间再来尝试获取。
  * **tryLock(long timeout,TimeUnit unit)**：如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；响应中断
  * **lock()**：如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁
  * **lockInterruptibly**:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断（响应中断）

* **ReadWriteLock**

  * ReentrantLock 实现的锁定规则非常简单：每当一个线程具有锁定时，其他线程必须等待，直到该锁定可用。

  * 有时，当对数据结构的读取通常多于修改时，可以使用更复杂的称为**ReadWriteLock**(读写锁)的锁定结构，它允许有**多个并发读者**，同时还允许**一个写者**独占锁定。该方法在一般情况下（只读）提供了更大的并发性，同时在必要时仍提供独占访问的安全性。

    ```java
    public interface ReadWriteLock{
        Lock readLock();
        Lock writeLock();
    }
    ```

  * **ReentrantReadWriteLock**为两个锁提供了可重进入的加锁语义。

## 13. **实现一个线程的不同方式，并且说出区别？**

* 实现**Runnable**接口重写**run()**方法定义一个任务类，通过Thread t = new Thread(Runnable r);来创建一个线程
* 直接**extends Thread** 重写 **run()** 方法定义一个线程类
* **区别**:
  * 继承了Thread类后就不能再继承其他类了，实现Runnable接口则没有限制
  * extends方式编码简单
  * implements方式可以使多个线程共享一个target对象，所以非常适合多个线程用来处理同一份资源的情况，更符合面向对象的编程思想。

## 14. **wait()与sleep()的区别**

* sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复。
* wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

##  15. **线程之间的通信机制**

* 通过Object类中得三个方法wait()、notify()、notifyAll()来进行通信。它们都必须使用在synchronized方法或者synchronized语句块中。
* 调用wait()后将释放对象锁，然后进入无限等待状态，直到线程接收到notify()或者notifyAll()信号才进入可执行状态。
* Notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关。